# What is Bicep?

- Bicep is a Resource Manager template language that's used to declaratively deploy Azure resources. 
- Bicep is a domain-specific language, which means that it's designed for a specific scenario or "domain." 
- Bicep isn't meant to be used as a standard programming language for writing applications. 
- Bicep is used only to create Resource Manager templates. Bicep is intended to be easy to understand and straightforward to learn, regardless of your experience with other programming languages. 
- All resource types, API versions, and properties are valid in Bicep templates.


## Benefits of Bicep

Bicep provides many improvements over JSON for template authoring, including:

- <b>Simpler syntax</b>: Bicep provides a simpler syntax for writing templates. You can reference parameters and variables directly, without using complicated functions. String interpolation is used in place of concatenation to combine values for names and other items. You can reference the properties of a resource directly by using its symbolic name instead of complex reference statements. These syntax improvements help both with authoring and reading Bicep templates.

- <b>Modules</b>: You can break down complex template deployments into smaller module files and reference them in a main template. These modules provide easier management and greater reusability. You can even share your modules with your team.

- <b>Automatic dependency management</b>: In most situations, Bicep automatically detects dependencies between your resources. This process removes some of the work involved in template authoring.

- <b>Type validation and IntelliSense</b>: The Bicep extension for Visual Studio Code features rich validation and IntelliSense for all Azure resource type API definitions. This feature helps provide an easier authoring experience.


Take a look at the following example of a Bicep template that defines an Azure storage account. The name of the storage account is automatically generated by the template. After deployment, the resource ID is returned as output to the user who executes the template.


        param location string = resourceGroup().location
        param namePrefix string = 'storage'

        var storageAccountName = '${namePrefix}${uniqueString(resourceGroup().id)}'
        var storageAccountSku = 'Standard_RAGRS'

        resource storageAccount 'Microsoft.Storage/storageAccounts@2019-06-01' = {
        name: storageAccountName
        location: location
        kind: 'StorageV2'
        sku: {
            name: storageAccountSku
        }
        properties: {
            accessTier: 'Hot'
            supportsHttpsTrafficOnly: true
        }
        }

        output storageAccountId string = storageAccount.id